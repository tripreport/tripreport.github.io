<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WEB RADIO TERMINAL — Liquid Blueprint EQ + Audio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      margin: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      background: #020617;
      color: #e5e7eb;
      overflow: hidden;
    }
    canvas#eqCanvas {
      position: fixed;
      inset: 0;
      display: block;
    }

    .ui {
      position: absolute;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      pointer-events: none;
      z-index: 2;
    }
    .ui h1 {
      font-size: 14px;
      letter-spacing: 0.38em;
      text-transform: uppercase;
      font-weight: 500;
      color: #a7f3d0;
      text-shadow: 0 0 22px rgba(56, 189, 248, 0.7);
      white-space: nowrap;
    }
    .ui .subtitle {
      margin-top: 4px;
      font-size: 9px;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: #4ade80;
      opacity: 0.9;
    }

    .info-box {
      position: absolute;
      left: 6%;
      bottom: 9%;
      width: 42%;
      max-width: 560px;
      padding: 12px 16px;
      border-radius: 12px;
      background:
        radial-gradient(circle at 0 0, rgba(34, 197, 94, 0.18), transparent 55%),
        rgba(6, 12, 28, 0.96);
      border: 1px solid rgba(22, 163, 74, 0.9);
      box-shadow:
        0 22px 45px rgba(2, 6, 23, 0.96),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(16px);
      pointer-events: none;
      z-index: 2;
    }
    .info-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.22em;
      color: #6ee7b7;
      margin-bottom: 6px;
      opacity: 0.9;
    }
    .info-text {
      font-size: 12px;
      line-height: 1.5;
      color: #e5e7eb;
      min-height: 1.5em;
      word-break: break-word;
    }

    .control-panel {
      position: absolute;
      right: 6%;
      top: 50%;
      width: 230px;
      height: 320px;
      transform: translateY(-50%);
      background: radial-gradient(circle at 0 0, rgba(45, 212, 191, 0.18), transparent 60%),
        rgba(3, 7, 18, 0.97);
      border-radius: 14px;
      border: 1px solid rgba(56, 189, 248, 0.6);
      box-shadow:
        0 0 54px rgba(56, 189, 248, 0.38),
        0 0 0 1px rgba(15, 23, 42, 0.95);
      display: flex;
      flex-direction: column;
      padding: 10px 12px;
      z-index: 3;
      pointer-events: auto;
      overflow: hidden;
    }
    .control-panel::before {
      content: "";
      position: absolute;
      inset: 8px;
      border-radius: 10px;
      border: 1px dashed rgba(15, 118, 110, 0.6);
      pointer-events: none;
    }
    .control-header {
      position: relative;
      z-index: 1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.24em;
      color: #99f6e4;
      margin-bottom: 6px;
    }
    .control-header span:nth-child(2) {
      font-size: 8px;
      color: rgba(148, 163, 184, 0.9);
      letter-spacing: 0.18em;
    }
    .control-grid {
      position: relative;
      z-index: 1;
      margin-top: 4px;
      padding-top: 4px;
      border-top: 1px solid rgba(30, 64, 175, 0.7);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .cp-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .cp-row span {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: rgba(148, 163, 184, 0.95);
      white-space: nowrap;
    }
    .cp-row input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 3px;
      background: rgba(15, 23, 42, 0.95);
      border-radius: 999px;
      outline: none;
    }
    .cp-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 11px;
      height: 11px;
      border-radius: 50%;
      background: #22c55e;
      box-shadow: 0 0 12px rgba(34, 197, 94, 0.9);
      cursor: pointer;
      border: 1px solid rgba(5, 150, 105, 1);
    }
    .cp-row input[type="range"]::-moz-range-thumb {
      width: 11px;
      height: 11px;
      border-radius: 50%;
      background: #22c55e;
      box-shadow: 0 0 12px rgba(34, 197, 94, 0.9);
      cursor: pointer;
      border: 1px solid rgba(5, 150, 105, 1);
    }
    .cp-row input[type="range"]::-moz-range-track {
      height: 3px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.95);
    }
    .cp-small {
      font-size: 8px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: rgba(100, 116, 139, 0.95);
      margin-top: 4px;
    }

    /* Параметрические блоки под линией эквалайзера */
    .param-block {
      width: 420px;
      height: 320px;
      position: absolute;
      border-radius: 10px;
      background-color: #0000009c;
      z-index: 5;
      bottom: 4%;
      padding: 10px 14px;
      border: 1px solid rgba(15, 23, 42, 0.9);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(18px);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .param-block--left {
      left: 4%;
    }
    .param-block--center {
      left: 50%;
      transform: translateX(-50%);
    }
    .param-block--right {
      right: 4%;
    }
    .param-block-title {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.22em;
      color: #6ee7b7;
      margin-bottom: 4px;
      opacity: 0.9;
    }
    .param-block-sub {
      font-size: 8px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: rgba(148, 163, 184, 0.9);
      margin-bottom: 6px;
    }
    .param-line {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #e5e7eb;
      border-bottom: 1px dashed rgba(30, 64, 175, 0.7);
      padding: 2px 0;
    }
    .param-line span:first-child {
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: rgba(148, 163, 184, 0.95);
    }
    .param-line span:last-child {
      color: #bfdbfe;
    }

    /* Аудио-"рабочий стол" с иконками и bokeh-инпутом */
    .audio-desktop {
      position: absolute;
      left: 6%;
      top: 18%;
      right: 30%;
      bottom: 28%;
      border-radius: 18px;
      background:
        radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.14), transparent 55%),
        radial-gradient(circle at 100% 100%, rgba(34, 197, 94, 0.12), transparent 55%),
        rgba(3, 7, 18, 0.9);
      border: 1px solid rgba(30, 64, 175, 0.7);
      box-shadow: 0 22px 60px rgba(15, 23, 42, 0.95);
      backdrop-filter: blur(22px);
      padding: 14px 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 4;
    }
    .audio-desktop--hover {
      border-color: rgba(56, 189, 248, 0.9);
      box-shadow:
        0 0 0 1px rgba(56, 189, 248, 0.5),
        0 26px 70px rgba(15, 23, 42, 0.98);
    }
    .audio-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .audio-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.24em;
      color: #99f6e4;
      white-space: nowrap;
    }
    .audio-url-group {
      flex: 1;
      display: flex;
      gap: 6px;
      align-items: center;
    }
    .audio-url-group input {
      flex: 1;
      background: radial-gradient(circle at 0 0, rgba(15, 23, 42, 0.9), rgba(15, 23, 42, 0.95));
      border-radius: 999px;
      border: 1px solid rgba(30, 64, 175, 0.9);
      padding: 6px 12px;
      font-size: 10px;
      color: #e5e7eb;
      outline: none;
    }
    .audio-url-group input::placeholder {
      color: rgba(148, 163, 184, 0.7);
      text-transform: lowercase;
    }
    .audio-url-group button {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid rgba(56, 189, 248, 0.7);
      background: radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.21), rgba(15, 23, 42, 1));
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: #e0f2fe;
      cursor: pointer;
    }
    .audio-url-group button:hover {
      background: radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.35), rgba(15, 23, 42, 1));
    }

    .audio-icons {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
      gap: 10px;
      padding: 8px 4px;
    }
    .audio-icon {
      position: relative;
      border-radius: 14px;
      border: 1px solid rgba(22, 163, 74, 0.35);
      background:
        radial-gradient(circle at 0 0, rgba(22, 163, 74, 0.18), transparent 55%),
        rgba(2, 6, 23, 0.9);
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      overflow: hidden;
    }
    .audio-icon::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 0 0, rgba(251, 191, 36, 0.08), transparent 55%);
      opacity: 0;
      transition: opacity 0.2s;
    }
    .audio-icon:hover::before {
      opacity: 1;
    }
    .audio-icon svg {
      width: 42px;
      height: 42px;
      opacity: 0.9;
    }
    .audio-icon-label {
      position: absolute;
      bottom: 6px;
      left: 8px;
      right: 8px;
      font-size: 8px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: rgba(148, 163, 184, 0.95);
      text-overflow: ellipsis;
      white-space: nowrap;
      overflow: hidden;
    }

    .audio-controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      border-radius: 999px;
      border: 1px solid rgba(30, 64, 175, 0.8);
      padding: 6px 10px;
      background: radial-gradient(circle at 0 100%, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 1));
    }
    .audio-btn {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 1px solid rgba(56, 189, 248, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 0 14px rgba(56, 189, 248, 0.5);
      background: radial-gradient(circle at 0 0, rgba(56, 189, 248, 0.3), rgba(15, 23, 42, 1));
      font-size: 11px;
      color: #e0f2fe;
    }
    .audio-btn--secondary {
      border-color: rgba(148, 163, 184, 0.9);
      box-shadow: 0 0 10px rgba(148, 163, 184, 0.5);
      background: radial-gradient(circle at 0 0, rgba(148, 163, 184, 0.35), rgba(15, 23, 42, 1));
    }
    .audio-btn:active {
      transform: scale(0.96);
    }
    .audio-status {
      flex: 1;
      font-size: 9px;
      color: rgba(148, 163, 184, 0.95);
      text-transform: uppercase;
      letter-spacing: 0.16em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .audio-meter {
      width: 74px;
      height: 6px;
      border-radius: 999px;
      border: 1px solid rgba(30, 64, 175, 0.9);
      display: flex;
      align-items: center;
      padding: 0 2px;
      gap: 2px;
    }
    .audio-meter-bar {
      flex: 1;
      height: 2px;
      border-radius: 999px;
      background: rgba(30, 64, 175, 0.8);
    }
    .audio-meter-bar--active {
      background: linear-gradient(to right, rgba(56, 189, 248, 0.9), rgba(34, 197, 94, 0.9));
    }

    #audioPlayer {
      display: none;
    }

    @media (max-width: 1600px) {
      .param-block {
        width: 360px;
        height: 260px;
      }
    }

    @media (max-width: 1280px) {
      .info-box {
        left: 5%;
        right: 5%;
        width: auto;
      }
      .control-panel {
        right: 5%;
        width: 200px;
        height: 300px;
      }
      .ui h1 {
        font-size: 11px;
        letter-spacing: 0.24em;
      }
      .param-block {
        width: 320px;
        height: 240px;
      }
      .audio-desktop {
        right: 4%;
        bottom: 32%;
      }
    }

    @media (max-width: 1024px) {
      .param-block--left {
        left: 3%;
      }
      .param-block--right {
        right: 3%;
      }
      .param-block--center {
        display: none;
      }
      .audio-desktop {
        left: 4%;
        right: 4%;
        bottom: 45%;
      }
    }

    @media (max-width: 720px) {
      .control-panel {
        top: auto;
        bottom: 8%;
        transform: none;
        width: calc(100% - 10%);
        left: 5%;
        right: 5%;
        height: auto;
      }
      .info-box {
        bottom: 24%;
        width: calc(100% - 10%);
      }
      .param-block {
        width: calc(100% - 10%);
        left: 5%;
        right: 5%;
        height: 200px;
      }
      .param-block--left {
        bottom: 28%;
      }
      .param-block--right {
        bottom: 4%;
      }
      .audio-desktop {
        top: 20%;
        bottom: auto;
        height: 220px;
      }
    }
  </style>
</head>
<body>
  <canvas id="eqCanvas"></canvas>

  <div class="ui">
    <h1>WEB RADIO TERMINAL</h1>
    <div class="subtitle">abstract hackers liquid equalizer</div>
  </div>

  <div class="info-box">
    <div class="info-label">stream / now playing</div>
    <div class="info-text" id="infoText"></div>
  </div>

  <div class="control-panel" id="controlPanel">
    <div class="control-header">
      <span>eq control</span>
      <span>session: 0xA1</span>
    </div>
    <div class="control-grid">
      <div class="cp-row">
        <span>intensity</span>
        <input
          type="range"
          min="0.4"
          max="2"
          step="0.02"
          value="1.1"
          data-prop="eqIntensity"
        />
      </div>
      <div class="cp-row">
        <span>tempo</span>
        <input
          type="range"
          min="0.4"
          max="1.8"
          step="0.02"
          value="1"
          data-prop="speed"
        />
      </div>
      <div class="cp-row">
        <span>liquid</span>
        <input
          type="range"
          min="0"
          max="1.4"
          step="0.02"
          value="0.8"
          data-prop="noise"
        />
      </div>
      <div class="cp-row">
        <span>grid warp</span>
        <input
          type="range"
          min="0"
          max="1.4"
          step="0.02"
          value="0.4"
          data-prop="warp"
        />
      </div>
      <div class="cp-row">
        <span>ux tempo</span>
        <input
          type="range"
          min="0.4"
          max="2"
          step="0.02"
          value="1"
          data-prop="uxTempo"
        />
      </div>
      <div class="cp-row">
        <span>ux density</span>
        <input
          type="range"
          min="0"
          max="1"
          step="0.02"
          value="0.5"
          data-prop="uxDensity"
        />
      </div>
      <div class="cp-row">
        <span>ux sync</span>
        <input
          type="range"
          min="0"
          max="1"
          step="0.02"
          value="0.8"
          data-prop="uxSync"
        />
      </div>
      <div class="cp-row">
        <span>text speed</span>
        <input
          type="range"
          min="0.3"
          max="2"
          step="0.02"
          value="1"
          data-prop="textSpeed"
        />
      </div>
      <div class="cp-row">
        <span>text glitch</span>
        <input
          type="range"
          min="0"
          max="1"
          step="0.02"
          value="0.3"
          data-prop="textGlitch"
        />
      </div>
      <div class="cp-small">
        routing: web_radio::blueprint_eq + typographic_engine // audio-reactive
      </div>
    </div>
  </div>

  <!-- Аудио-"рабочий стол" -->
  <div class="audio-desktop" id="audioDesktop">
    <div class="audio-header">
      <div class="audio-title">audio workspace</div>
      <div class="audio-url-group">
        <input id="audioUrl" type="text" placeholder="https://musicsource/track.mp3" />
        <button id="audioUrlLoad">load</button>
      </div>
    </div>
    <div class="audio-icons" id="audioIcons">
      <div class="audio-icon" data-role="upload">
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
          <rect x="10" y="10" width="44" height="44" rx="6" ry="6" fill="none" stroke="rgba(56,189,248,0.9)" stroke-width="2" />
          <path d="M22 40 L42 40" stroke="rgba(56,189,248,0.9)" stroke-width="2" stroke-linecap="round" />
          <path d="M32 19 L32 35" stroke="rgba(34,197,94,0.95)" stroke-width="2" stroke-linecap="round" />
          <path d="M26 25 L32 19 L38 25" stroke="rgba(34,197,94,0.95)" stroke-width="2" stroke-linecap="round" fill="none" />
        </svg>
        <div class="audio-icon-label">local file</div>
      </div>
      <div class="audio-icon" data-role="slot">
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
          <rect x="12" y="12" width="40" height="40" rx="4" ry="4" fill="none" stroke="rgba(45,212,191,0.9)" stroke-width="2" />
          <circle cx="28" cy="28" r="6" fill="none" stroke="rgba(45,212,191,0.9)" stroke-width="2" />
          <path d="M36 24 L44 22 L44 40" fill="none" stroke="rgba(190,242,100,0.9)" stroke-width="2" />
          <circle cx="44" cy="40" r="3" fill="rgba(190,242,100,0.9)" />
        </svg>
        <div class="audio-icon-label">slot 01</div>
      </div>
      <div class="audio-icon" data-role="slot">
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
          <rect x="12" y="12" width="40" height="40" rx="4" ry="4" fill="none" stroke="rgba(129,140,248,0.9)" stroke-width="2" />
          <path d="M20 40 C26 30 38 30 44 20" fill="none" stroke="rgba(129,140,248,0.9)" stroke-width="2" />
          <circle cx="22" cy="38" r="3" fill="rgba(56,189,248,0.9)" />
          <circle cx="40" cy="24" r="3" fill="rgba(34,197,94,0.9)" />
        </svg>
        <div class="audio-icon-label">slot 02</div>
      </div>
      <div class="audio-icon" data-role="slot">
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
          <rect x="12" y="12" width="40" height="40" rx="4" ry="4" fill="none" stroke="rgba(251,191,36,0.9)" stroke-width="2" />
          <path d="M24 38 L36 26" fill="none" stroke="rgba(251,191,36,0.9)" stroke-width="2" />
          <circle cx="24" cy="38" r="3" fill="rgba(56,189,248,0.9)" />
          <circle cx="36" cy="26" r="3" fill="rgba(34,197,94,0.9)" />
        </svg>
        <div class="audio-icon-label">slot 03</div>
      </div>
    </div>
    <div class="audio-controls">
      <div class="audio-btn" id="audioPlay">▶</div>
      <div class="audio-btn audio-btn--secondary" id="audioPause">⏸</div>
      <div class="audio-status" id="audioStatus">no source loaded</div>
      <div class="audio-meter" id="audioMeter">
        <div class="audio-meter-bar"></div>
        <div class="audio-meter-bar"></div>
        <div class="audio-meter-bar"></div>
        <div class="audio-meter-bar"></div>
        <div class="audio-meter-bar"></div>
      </div>
    </div>
  </div>

  <!-- Параметрические блоки под линией эквалайзера -->
  <div class="param-block param-block--left">
    <div class="param-block-title">grid / warp metrics</div>
    <div class="param-block-sub">dynamic blueprint field</div>
    <div class="param-line">
      <span>warp base</span><span id="pbWarpBase">0.00</span>
    </div>
    <div class="param-line">
      <span>warp effective</span><span id="pbWarpEff">0.00</span>
    </div>
    <div class="param-line">
      <span>mouse x</span><span id="pbMouseX">0.00</span>
    </div>
    <div class="param-line">
      <span>mouse y</span><span id="pbMouseY">0.00</span>
    </div>
  </div>

  <div class="param-block param-block--center">
    <div class="param-block-title">eq / energy metrics</div>
    <div class="param-block-sub">liquid equalizer state</div>
    <div class="param-line">
      <span>global energy</span><span id="pbEnergy">0.00</span>
    </div>
    <div class="param-line">
      <span>intensity</span><span id="pbIntensity">1.10</span>
    </div>
    <div class="param-line">
      <span>tempo</span><span id="pbSpeed">1.00</span>
    </div>
    <div class="param-line">
      <span>liquid noise</span><span id="pbNoise">0.80</span>
    </div>
  </div>

  <div class="param-block param-block--right">
    <div class="param-block-title">ux scenario</div>
    <div class="param-block-sub">grid lighting pattern</div>
    <div class="param-line">
      <span>ux tempo</span><span id="pbUxTempo">1.00</span>
    </div>
    <div class="param-line">
      <span>ux density</span><span id="pbUxDensity">0.50</span>
    </div>
    <div class="param-line">
      <span>ux sync</span><span id="pbUxSync">0.80</span>
    </div>
    <div class="param-line">
      <span>scenario phase</span><span id="pbUxPhase">idle</span>
    </div>
  </div>

  <input type="file" id="audioFileInput" accept="audio/*" style="display:none" />
  <audio id="audioPlayer" preload="auto"></audio>

  <script>
    (() => {
      const canvas = document.getElementById('eqCanvas');
      const ctx = canvas.getContext('2d');
      const infoEl = document.getElementById('infoText');

      // param-block elements
      const pbWarpBase = document.getElementById('pbWarpBase');
      const pbWarpEff = document.getElementById('pbWarpEff');
      const pbMouseX = document.getElementById('pbMouseX');
      const pbMouseY = document.getElementById('pbMouseY');
      const pbEnergy = document.getElementById('pbEnergy');
      const pbIntensity = document.getElementById('pbIntensity');
      const pbSpeed = document.getElementById('pbSpeed');
      const pbNoise = document.getElementById('pbNoise');
      const pbUxTempo = document.getElementById('pbUxTempo');
      const pbUxDensity = document.getElementById('pbUxDensity');
      const pbUxSync = document.getElementById('pbUxSync');
      const pbUxPhase = document.getElementById('pbUxPhase');

      // audio elements
      const audioEl = document.getElementById('audioPlayer');
      const audioFileInput = document.getElementById('audioFileInput');
      const audioDesktop = document.getElementById('audioDesktop');
      const audioIconsContainer = document.getElementById('audioIcons');
      const audioStatusEl = document.getElementById('audioStatus');
      const audioPlayBtn = document.getElementById('audioPlay');
      const audioPauseBtn = document.getElementById('audioPause');
      const audioUrlInput = document.getElementById('audioUrl');
      const audioUrlLoadBtn = document.getElementById('audioUrlLoad');
      const audioMeterBars = document.querySelectorAll('.audio-meter-bar');

      let width = 0;
      let height = 0;

      const bandCount = 72;
      const bands = [];

      const controls = {
        eqIntensity: 1.1,
        speed: 1,
        noise: 0.8,
        warp: 0.4,
        uxTempo: 1.0,
        uxDensity: 0.5,
        uxSync: 0.8,
        textSpeed: 1.0,
        textGlitch: 0.3
      };

      // equalizer energy + warp / mouse
      let globalEnergy = 0;
      let effectiveWarp = controls.warp;
      let mouseNormX = 0.5;
      let mouseNormY = 0.5;

      // audio analysis
      let audioCtx = null;
      let analyser = null;
      let sourceNode = null;
      let dataArray = null;
      let bufferLength = 0;
      let audioActive = false;
      let audioReady = false;
      let lastAudioEnergy = 0;

      // glitch glyph set (цифровая / радиотехническая символика)
      const glitchGlyphs = '01ΔΣΞΩ≈∿λµΩƒ≋▌▐▒░▓█#/%\\|+<>⧉⧖⧈◊⌁⌂↯';

      const infoLines = [
        'ABSTRACT HACKERS RADIO // CHANNEL: 0x1F | MODE: LIQUID BLUEPRINT EQ',
        'STREAM ROUTING: WEB_RADIO \u21e2 TERMINAL_UI \u21e2 LIQUID_EQUALIZER \u21e2 LISTENER',
        'NO AUDIO INPUT BOUND \u2014 RUNNING IN SYNTHETIC PROBABILISTIC EQ MODE',
        'SESSION LOG: SPECTRAL WIREFRAME ACTIVE / PARTICLE FEED REROUTED TO EQ',
        'SCANNING PORTS 8000\u20138100 FOR LIVE ICECAST / SHOUTCAST STREAMS\u2026',
        'PIPELINE: GRID_OSCILLATOR \xd7 PARTICLE_FIELD \xd7 WIREFRAME_LIQUID_EQ'
      ];
      let infoIndex = 0;
      let infoElapsed = 0; // seconds
      const infoDuration = 11; // seconds per line

      function clamp01(v) {
        if (v < 0) return 0;
        if (v > 1) return 1;
        return v;
      }

      function smoothstep01(v) {
        const x = clamp01(v);
        return x * x * (3 - 2 * x);
      }

      function fract(x) {
        return x - Math.floor(x);
      }

      function randCell(ix, iy, segment) {
        return fract(
          Math.sin(ix * 127.1 + iy * 311.7 + segment * 7.13) * 43758.5453
        );
      }

      function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
      }

      function initBands() {
        bands.length = 0;
        const now = performance.now();
        for (let i = 0; i < bandCount; i++) {
          bands.push({
            value: Math.random() * 0.4,
            target: 0.3 + Math.random() * 0.7,
            pulse: Math.random() * Math.PI * 2,
            lastTargetTime: now - Math.random() * 3000,
            display: 0
          });
        }
      }

      function hookControls() {
        document
          .querySelectorAll('.control-panel input[type="range"]')
          .forEach((input) => {
            const prop = input.dataset.prop;
            if (!prop) return;
            controls[prop] = parseFloat(input.value);
            input.addEventListener('input', () => {
              controls[prop] = parseFloat(input.value);
            });
          });

        window.addEventListener('mousemove', (e) => {
          mouseNormX = width > 0 ? e.clientX / width : 0.5;
          mouseNormY = height > 0 ? e.clientY / height : 0.5;
        });

        window.addEventListener(
          'touchmove',
          (e) => {
            if (!e.touches || !e.touches[0]) return;
            const t = e.touches[0];
            mouseNormX = width > 0 ? t.clientX / width : 0.5;
            mouseNormY = height > 0 ? t.clientY / height : 0.5;
          },
          { passive: true }
        );

        if (audioIconsContainer) {
          const icons = audioIconsContainer.querySelectorAll('.audio-icon');
          icons.forEach((icon) => {
            const role = icon.dataset.role;
            if (role === 'upload') {
              icon.addEventListener('click', () => {
                if (audioFileInput) audioFileInput.click();
              });
            }
          });
        }

        if (audioFileInput) {
          audioFileInput.addEventListener('change', (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            if (!file.type.startsWith('audio/')) return;
            const url = URL.createObjectURL(file);
            loadAudioSource(url, file.name);
          });
        }

        if (audioDesktop) {
          audioDesktop.addEventListener('dragover', (e) => {
            e.preventDefault();
            audioDesktop.classList.add('audio-desktop--hover');
          });
          audioDesktop.addEventListener('dragleave', (e) => {
            e.preventDefault();
            audioDesktop.classList.remove('audio-desktop--hover');
          });
          audioDesktop.addEventListener('drop', (e) => {
            e.preventDefault();
            audioDesktop.classList.remove('audio-desktop--hover');
            const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
            if (!file) return;
            if (!file.type.startsWith('audio/')) return;
            const url = URL.createObjectURL(file);
            loadAudioSource(url, file.name);
          });
        }

        if (audioUrlLoadBtn && audioUrlInput) {
          audioUrlLoadBtn.addEventListener('click', () => {
            const url = audioUrlInput.value.trim();
            if (!url) return;
            loadAudioSource(url, 'remote track');
          });
          audioUrlInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              audioUrlLoadBtn.click();
            }
          });
        }

        if (audioPlayBtn) {
          audioPlayBtn.addEventListener('click', () => {
            if (!audioEl.src) return;
            setupAudioGraph();
            if (audioCtx && audioCtx.state === 'suspended') {
              audioCtx.resume();
            }
            audioEl
              .play()
              .then(() => {
                audioActive = true;
              })
              .catch(() => {});
          });
        }
        if (audioPauseBtn) {
          audioPauseBtn.addEventListener('click', () => {
            audioEl.pause();
          });
        }

        if (audioEl) {
          audioEl.addEventListener('play', () => {
            audioActive = true;
            setAudioStatus('playing');
          });
          audioEl.addEventListener('pause', () => {
            audioActive = false;
            setAudioStatus('paused');
          });
          audioEl.addEventListener('ended', () => {
            audioActive = false;
            setAudioStatus('ended');
          });
          audioEl.addEventListener('error', () => {
            audioActive = false;
            setAudioStatus('error loading audio');
          });
        }
      }

      function setupAudioGraph() {
        if (audioCtx || !audioEl) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) {
          setAudioStatus('audio context not supported');
          return;
        }
        audioCtx = new AC();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        sourceNode = audioCtx.createMediaElementSource(audioEl);
        sourceNode.connect(analyser);
        analyser.connect(audioCtx.destination);
      }

      function loadAudioSource(url, label) {
        if (!url) return;
        setupAudioGraph();
        if (!audioCtx || !audioEl) {
          setAudioStatus('audio context not available');
          return;
        }
        try {
          audioEl.crossOrigin = 'anonymous';
        } catch (e) {}
        audioEl.src = url;
        audioReady = true;
        audioActive = false;
        setAudioStatus('loading\u2026');
        audioEl.load();
        audioCtx.resume();
        audioEl
          .play()
          .then(() => {
            audioActive = true;
            setAudioStatus('playing: ' + (label || url));
          })
          .catch(() => {
            setAudioStatus('tap play to start');
          });
      }

      function setAudioStatus(text) {
        if (audioStatusEl) {
          audioStatusEl.textContent = text;
        }
      }

      // Параметрический генератор динамики цифровой типографии
      function updateInfo(dt) {
        const speed = controls.textSpeed || 1;
        const glitchBase = controls.textGlitch || 0;

        infoElapsed += dt * speed;
        if (infoElapsed > infoDuration) {
          infoElapsed -= infoDuration;
          infoIndex = (infoIndex + 1) % infoLines.length;
        }

        const phase = infoElapsed / infoDuration; // 0..1

        const text = infoLines[infoIndex];
        const len = text.length;

        // плавное появление / растворение строки
        let revealPhase;
        if (phase < 0.5) {
          revealPhase = smoothstep01(phase / 0.5);
        } else {
          revealPhase = smoothstep01((1 - phase) / 0.5);
        }

        const visibleLen = Math.max(0, Math.floor(len * revealPhase));
        const raw = text.slice(0, visibleLen);

        // синхронизация глитча с энергией EQ + фазой цикла
        const centerWeight = 1 - Math.abs(phase - 0.5) * 2; // 0 на краях, 1 в центре
        let glitchIntensity =
          glitchBase * 0.7 + globalEnergy * 0.6 * (0.3 + 0.7 * centerWeight);
        glitchIntensity = clamp01(glitchIntensity);

        let result = '';
        for (let i = 0; i < raw.length; i++) {
          const ch = raw[i];

          if (ch === ' ' || ch === '/' || ch === ':' || ch === '-' || ch === '·') {
            result += ch;
            continue;
          }

          const local =
            (Math.sin(infoElapsed * 1.7 + i * 13.37) + 1) * 0.5;
          const prob = glitchIntensity * local;

          if (Math.random() < prob) {
            const idx = Math.floor(Math.random() * glitchGlyphs.length);
            result += glitchGlyphs[idx];
          } else {
            result += ch;
          }
        }

        infoEl.textContent = result;
      }

      function updateBands(now, dt) {
        const speed = controls.speed;
        const noise = controls.noise;

        // если аудио активно, используем его спектр
        if (audioActive && analyser && dataArray && bufferLength > 0) {
          analyser.getByteFrequencyData(dataArray);
          let sum = 0;
          for (let i = 0; i < bandCount; i++) {
            const idx = Math.floor((i / bandCount) * bufferLength);
            const v = dataArray[idx] / 255;
            bands[i].display = v;
            sum += v;
          }
          const avg = sum / bandCount;
          const smooth = 0.8 * lastAudioEnergy + 0.2 * avg;
          lastAudioEnergy = smooth;
          globalEnergy = clamp01(smooth * 1.3);
          return;
        }

        // синтетический режим, когда аудио нет
        let sum = 0;
        bands.forEach((band, i) => {
          const baseChangeProb = 0.02 * speed;
          const accent = (i % 7 === 0 ? 0.012 : 0) + (i % 11 === 0 ? 0.01 : 0);
          const changeProb =
            baseChangeProb +
            accent +
            0.004 * Math.sin((now * 0.0012 + i * 0.31) % (Math.PI * 2));

          if (Math.random() < changeProb * dt * 60) {
            const edgeBoost = Math.abs(i / bandCount - 0.5) * 0.5;
            band.target = 0.15 + Math.random() * (0.6 + edgeBoost);
            band.lastTargetTime = now;
          }

          const baseSpeed = 3 + speed * 3.5;
          const lerp = 1 - Math.exp(-baseSpeed * dt);
          band.value += (band.target - band.value) * lerp;

          const wave =
            Math.sin(now * 0.0016 + band.pulse + i * 0.15) * 0.18 * noise +
            Math.cos(now * 0.0009 + i * 0.27) * 0.12 * noise;

          let v = band.value + wave;
          v = Math.max(0, Math.min(1.35, v));
          band.display = v;
          sum += v;
        });

        const avg = sum / bandCount;
        globalEnergy = clamp01(avg / 1.2);
      }

      // UX-сценарий мигающих ячеек
      function drawUXCells(now, eqEnergy, spacing) {
        const cellSize = spacing;
        const cols = Math.ceil(width / cellSize);
        const rows = Math.ceil(height / cellSize);

        const uxTempo = controls.uxTempo;
        const density = controls.uxDensity;
        const sync = controls.uxSync;

        const time = now * 0.001 * uxTempo;
        const segment = Math.floor(time * 2.0);
        const cycleLen = 6.0;
        const cyclePos = fract(time / cycleLen);

        if (pbUxPhase) {
          let phaseLabel = 'idle';
          if (cyclePos >= 0.33 && cyclePos < 0.66) {
            phaseLabel = 'cluster';
          } else if (cyclePos >= 0.66) {
            phaseLabel = 'flow';
          }
          pbUxPhase.textContent = phaseLabel;
        }

        const eqBoost = eqEnergy * sync;

        for (let ix = 0; ix < cols; ix++) {
          for (let iy = 0; iy < rows; iy++) {
            const baseR = randCell(ix, iy, segment);
            let patternWeight = 0;

            const nx = cols > 1 ? ix / (cols - 1) : 0.5;
            const ny = rows > 1 ? iy / (rows - 1) : 0.5;
            const centerDist =
              Math.hypot(nx - 0.5, ny - 0.5) / Math.SQRT2;

            if (cyclePos < 0.33) {
              const diag = 1 - Math.abs(nx - ny);
              patternWeight = 0.6 * baseR + 0.4 * diag;
            } else if (cyclePos < 0.66) {
              const centerBias = 1 - centerDist;
              patternWeight = 0.4 * baseR + 0.6 * centerBias;
            } else {
              const sweepCenter = fract(time * 0.12);
              const sweep = 1 - Math.abs(nx - sweepCenter);
              patternWeight = 0.5 * baseR + 0.5 * Math.max(0, sweep);
            }

            let activation = patternWeight + eqBoost;

            const threshold = 0.98 - 0.35 * density;
            if (activation > threshold) {
              const strength = clamp01((activation - threshold) / (1 - threshold));
              const x = ix * cellSize;
              const y = iy * cellSize;
              const margin = 4;
              const w = cellSize - margin * 2;
              const h = cellSize - margin * 2;

              const band = (ix + iy) % 4;
              let color;
              if (band === 0) {
                color = `rgba(56, 189, 248, ${0.4 + 0.5 * strength})`;
              } else if (band === 1) {
                color = `rgba(45, 212, 191, ${0.4 + 0.5 * strength})`;
              } else if (band === 2) {
                color = `rgba(190, 242, 100, ${0.4 + 0.5 * strength})`;
              } else {
                color = `rgba(129, 140, 248, ${0.4 + 0.5 * strength})`;
              }

              ctx.beginPath();
              ctx.rect(x + margin, y + margin, w, h);
              ctx.fillStyle = `rgba(2, 6, 23, ${0.6 + 0.3 * strength})`;
              ctx.fill();

              ctx.beginPath();
              ctx.rect(x + margin, y + margin, w, h);
              ctx.strokeStyle = color;
              ctx.lineWidth = 1;
              ctx.stroke();

              if (baseR > 0.7) {
                ctx.beginPath();
                ctx.moveTo(x + margin + 2, y + margin + 2);
                ctx.lineTo(x + margin + w - 2, y + margin + h - 2);
                ctx.moveTo(x + margin + w - 2, y + margin + 2);
                ctx.lineTo(x + margin + 2, y + margin + h - 2);
                ctx.strokeStyle = `rgba(15, 23, 42, ${0.85})`;
                ctx.lineWidth = 0.7;
                ctx.stroke();
              } else if (baseR > 0.4) {
                ctx.beginPath();
                ctx.moveTo(x + margin + 3, y + margin + 3);
                ctx.lineTo(x + margin + w - 6, y + margin + 3);
                ctx.lineTo(x + margin + w - 6, y + margin + h - 6);
                ctx.strokeStyle = `rgba(15, 23, 42, ${0.85})`;
                ctx.lineWidth = 0.7;
                ctx.stroke();
              } else {
                const cx = x + margin + w / 2;
                const cy = y + margin + h / 2;
                const s = 6 + 6 * strength;
                ctx.beginPath();
                ctx.rect(cx - s / 2, cy - s / 2, s, s);
                ctx.fillStyle = color;
                ctx.fill();
              }
            }
          }
        }
      }

      function drawBackgroundGrid(now) {
        ctx.save();
        ctx.fillStyle = '#020617';
        ctx.fillRect(0, 0, width, height);

        const spacing = 48;
        const t = now * 0.00045;

        const baseWarp = controls.warp;
        const mouseDist = Math.hypot(mouseNormX - 0.5, mouseNormY - 0.5) * 2;
        const mouseFactor = 0.5 + 0.8 * clamp01(mouseDist);
        const warp = baseWarp * mouseFactor;
        effectiveWarp = warp;

        ctx.lineWidth = 1;

        for (let x = 0; x <= width; x += spacing) {
          const phase = x * 0.005 + t * 4;
          const offset = Math.sin(phase) * 10 * warp;

          ctx.beginPath();
          ctx.moveTo(x + offset, 0);
          ctx.lineTo(x - offset, height);
          ctx.strokeStyle = 'rgba(15, 23, 42, 1)';
          ctx.stroke();

          const glowAlpha = 0.05 + 0.08 * (0.5 + 0.5 * Math.sin(phase * 0.7));
          ctx.beginPath();
          ctx.moveTo(x + offset, 0);
          ctx.lineTo(x - offset, height);
          ctx.strokeStyle = `rgba(37, 99, 235, ${glowAlpha})`;
          ctx.stroke();
        }

        for (let y = 0; y <= height; y += spacing) {
          const phase = y * 0.006 + t * 3.2;
          const offset = Math.cos(phase) * 14 * warp;

          ctx.beginPath();
          ctx.moveTo(0, y + offset);
          ctx.lineTo(width, y - offset);
          ctx.strokeStyle = 'rgba(15, 23, 42, 1)';
          ctx.stroke();

          const glowAlpha = 0.04 + 0.07 * (0.5 + 0.5 * Math.cos(phase * 0.9));
          ctx.beginPath();
          ctx.moveTo(0, y + offset);
          ctx.lineTo(width, y - offset);
          ctx.strokeStyle = `rgba(8, 47, 73, ${glowAlpha})`;
          ctx.stroke();
        }

        drawUXCells(now, globalEnergy, spacing);

        ctx.restore();
      }

      function drawWireframeContours(now) {
        ctx.save();
        const marginTop = height * 0.14;
        const marginBottom = height * 0.18;

        ctx.setLineDash([6, 9]);
        ctx.lineWidth = 1;

        ctx.strokeStyle = 'rgba(30, 64, 175, 0.8)';
        ctx.beginPath();
        ctx.moveTo(0, marginTop);
        ctx.lineTo(width, marginTop);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, height - marginBottom);
        ctx.lineTo(width, height - marginBottom);
        ctx.stroke();

        ctx.setLineDash([10, 14]);
        ctx.strokeStyle = 'rgba(8, 47, 73, 0.9)';
        ctx.beginPath();
        ctx.moveTo(width * 0.08, height - marginBottom);
        ctx.lineTo(width * 0.32, marginTop);
        ctx.lineTo(width * 0.66, height - marginBottom * 0.55);
        ctx.lineTo(width * 0.92, marginTop * 1.05);
        ctx.stroke();

        const t = now * 0.0015;
        const hubs = [
          { x: width * 0.18, y: height - marginBottom },
          { x: width * 0.5, y: marginTop },
          { x: width * 0.82, y: height - marginBottom * 0.55 }
        ];
        hubs.forEach((h, i) => {
          const r = 4 + 1.5 * Math.sin(t * 2.1 + i);
          ctx.beginPath();
          ctx.arc(h.x, h.y, r, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(56, 189, 248, 0.85)';
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(h.x, h.y, r * 0.45, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(34, 197, 94, 0.9)';
          ctx.fill();
        });

        ctx.restore();
      }

      // EQ волна по центру + зеркальное отражение
      function drawLiquidEqualizer(now) {
        ctx.save();

        const marginTop = height * 0.16;
        const marginBottom = height * 0.18;
        const yTopLimit = marginTop;
        const yBottomLimit = height - marginBottom;
        const centerY = (yTopLimit + yBottomLimit) / 2;
        const halfHeight = (yBottomLimit - yTopLimit) / 2;
        const bandWidth = width / bandCount;
        const intensity = controls.eqIntensity;

        const waveTopPoints = [];
        const waveBottomPoints = [];

        for (let i = 0; i < bandCount; i++) {
          const band = bands[i];
          const xCenter = i * bandWidth + bandWidth * 0.5;
          const barHeightRaw = band.display * intensity * halfHeight;

          let yTop = centerY - barHeightRaw;
          let yBottom = centerY + barHeightRaw;

          if (yTop < yTopLimit) yTop = yTopLimit;
          if (yBottom > yBottomLimit) yBottom = yBottomLimit;

          const barLeft = xCenter - bandWidth * 0.35;
          const barRight = xCenter + bandWidth * 0.35;
          const barWidth = barRight - barLeft;
          const barHeight = yBottom - yTop || 1;

          const innerAlpha = 0.05 + 0.25 * clamp01(band.display);
          const grad = ctx.createLinearGradient(0, yTop, 0, yBottom);
          grad.addColorStop(0, `rgba(56, 189, 248, ${innerAlpha})`);
          grad.addColorStop(0.5, `rgba(15, 118, 110, ${innerAlpha * 0.7})`);
          grad.addColorStop(1, `rgba(37, 99, 235, ${innerAlpha})`);

          ctx.beginPath();
          ctx.rect(barLeft, yTop, barWidth, barHeight);
          ctx.fillStyle = grad;
          ctx.fill();

          ctx.beginPath();
          ctx.rect(barLeft, yTop, barWidth, barHeight);
          ctx.strokeStyle = `rgba(94, 234, 212, ${
            0.25 + 0.45 * clamp01(band.display)
          })`;
          ctx.lineWidth = i % 4 === 0 ? 1.2 : 0.9;
          ctx.stroke();

          if (i % 5 === 0) {
            const cellCount = 4;
            for (let c = 0; c < cellCount; c++) {
              const fy = yTop + (barHeight * ((c + 0.5) / cellCount));
              ctx.beginPath();
              ctx.moveTo(barLeft, fy);
              ctx.lineTo(barRight, fy);
              ctx.strokeStyle = 'rgba(15, 23, 42, 0.82)';
              ctx.lineWidth = 0.7;
              ctx.stroke();
            }
          }

          waveTopPoints.push({ x: xCenter, y: yTop });
          waveBottomPoints.push({ x: xCenter, y: yBottom });
        }

        // центральная линия
        ctx.setLineDash([4, 6]);
        ctx.beginPath();
        ctx.moveTo(0, centerY);
        ctx.lineTo(width, centerY);
        ctx.strokeStyle = 'rgba(15, 23, 42, 0.9)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.setLineDash([]);

        // верхняя волна
        ctx.beginPath();
        waveTopPoints.forEach((pt, i) => {
          if (i === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        });
        ctx.strokeStyle = 'rgba(94, 234, 212, 0.95)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // зеркальная нижняя волна
        ctx.beginPath();
        waveBottomPoints.forEach((pt, i) => {
          if (i === 0) ctx.moveTo(pt.x, pt.y);
          else ctx.lineTo(pt.x, pt.y);
        });
        ctx.strokeStyle = 'rgba(56, 189, 248, 0.8)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // подложка под область EQ
        const waveGrad = ctx.createLinearGradient(0, yTopLimit, 0, yBottomLimit);
        waveGrad.addColorStop(0, 'rgba(8, 47, 73, 0.0)');
        waveGrad.addColorStop(0.5, 'rgba(8, 47, 73, 0.35)');
        waveGrad.addColorStop(1, 'rgba(8, 47, 73, 0.95)');
        ctx.fillStyle = waveGrad;
        ctx.fillRect(0, yTopLimit, width, yBottomLimit - yTopLimit);

        // орбитальные ноды по верхней / нижней кривой
        const t = now * 0.0012;
        const nodeCount = 12;
        const palette = [
          'rgba(56, 189, 248, 0.9)',
          'rgba(45, 212, 191, 0.9)',
          'rgba(190, 242, 100, 0.9)',
          'rgba(129, 140, 248, 0.9)'
        ];

        for (let n = 0; n < nodeCount; n++) {
          const u = (t * (0.4 + controls.speed * 0.6) + n / nodeCount) % 1;
          const idxFloat = u * (waveTopPoints.length - 1);
          const i0 = Math.floor(idxFloat);
          const i1 = Math.min(waveTopPoints.length - 1, i0 + 1);
          const lerp = idxFloat - i0;

          const top0 = waveTopPoints[i0];
          const top1 = waveTopPoints[i1];
          const bottom0 = waveBottomPoints[i0];
          const bottom1 = waveBottomPoints[i1];

          const useBottom = n % 2 === 1;
          const p0 = useBottom ? bottom0 : top0;
          const p1 = useBottom ? bottom1 : top1;

          const x = p0.x + (p1.x - p0.x) * lerp;
          const y = p0.y + (p1.y - p0.y) * lerp;

          const baseRadius = 4 + 1.8 * Math.sin(t * 2.3 + n);
          const sides = 3 + (n % 4);
          const rotation = t * 1.8 + n * 0.7;
          const color = palette[n % palette.length];

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(rotation);

          ctx.beginPath();
          for (let k = 0; k < sides; k++) {
            const ang = (k / sides) * Math.PI * 2;
            const px = Math.cos(ang) * baseRadius;
            const py = Math.sin(ang) * baseRadius;
            if (k === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.strokeStyle = color;
          ctx.lineWidth = 1;
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(0, 0, baseRadius * 0.35, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(15, 23, 42, 0.9)';
          ctx.fill();

          ctx.beginPath();
          ctx.arc(0, 0, baseRadius * 0.2, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();

          ctx.beginPath();
          ctx.moveTo(-baseRadius * 0.6, 0);
          ctx.lineTo(baseRadius * 0.6, 0);
          ctx.moveTo(0, -baseRadius * 0.6);
          ctx.lineTo(0, baseRadius * 0.6);
          ctx.strokeStyle = 'rgba(15, 23, 42, 0.9)';
          ctx.lineWidth = 0.6;
          ctx.stroke();

          ctx.restore();
        }

        ctx.restore();
      }

      function updateAudioMeter() {
        if (!audioMeterBars) return;
        const level = audioActive ? lastAudioEnergy : 0;
        const count = audioMeterBars.length;
        const activeCount = Math.round(level * count);
        audioMeterBars.forEach((bar, idx) => {
          if (idx < activeCount) bar.classList.add('audio-meter-bar--active');
          else bar.classList.remove('audio-meter-bar--active');
        });
      }

      function updateParamBlocks() {
        if (pbWarpBase) pbWarpBase.textContent = controls.warp.toFixed(2);
        if (pbWarpEff) pbWarpEff.textContent = effectiveWarp.toFixed(2);
        if (pbMouseX) pbMouseX.textContent = mouseNormX.toFixed(2);
        if (pbMouseY) pbMouseY.textContent = mouseNormY.toFixed(2);

        if (pbEnergy) pbEnergy.textContent = globalEnergy.toFixed(2);
        if (pbIntensity) pbIntensity.textContent = controls.eqIntensity.toFixed(2);
        if (pbSpeed) pbSpeed.textContent = controls.speed.toFixed(2);
        if (pbNoise) pbNoise.textContent = controls.noise.toFixed(2);

        if (pbUxTempo) pbUxTempo.textContent = controls.uxTempo.toFixed(2);
        if (pbUxDensity) pbUxDensity.textContent = controls.uxDensity.toFixed(2);
        if (pbUxSync) pbUxSync.textContent = controls.uxSync.toFixed(2);

        updateAudioMeter();
      }

      let lastTime = null;

      function loop(now) {
        if (!lastTime) {
          lastTime = now;
        }
        const dt = Math.max(0.001, (now - lastTime) / 1000);
        lastTime = now;

        updateInfo(dt);
        updateBands(now, dt);

        drawBackgroundGrid(now);
        drawLiquidEqualizer(now);
        drawWireframeContours(now);
        updateParamBlocks();

        requestAnimationFrame(loop);
      }

      resize();
      initBands();
      hookControls();
      window.addEventListener('resize', resize);

      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
